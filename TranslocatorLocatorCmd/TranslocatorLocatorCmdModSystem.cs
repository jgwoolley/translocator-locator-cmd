#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using Nf3t.VintageStory.Common;
using Vintagestory.API.Client;
using Vintagestory.API.Common;
using Vintagestory.API.MathTools;
using Vintagestory.API.Util;
using Vintagestory.GameContent;

namespace Nf3t.VintageStory.TranslocatorLocatorCmd;

public class TranslocatorLocatorCmdModSystem : ModSystem
{
    public override bool ShouldLoad(EnumAppSide side)
    {
        return side == EnumAppSide.Client;
    }

    public override void StartClientSide(ICoreClientAPI api)
    {
        var config = Nf3tConfig.Load(api);
        var context = new Context(api);
        context.Load();

        api.ChatCommands.Create("findtl")
            .WithDescription("Finds nearby translocators.")
            // Added a boolean parser. Optional(false) makes it default to false if omitted.
            .WithArgs(
                api.ChatCommands.Parsers.OptionalBool("addWaypoints"),
                api.ChatCommands.Parsers.OptionalInt("radius", config.DefaultSearchRadius))
            .HandleWith(args =>
            {
                var addWaypoints = true.Equals(args[0]);
                var radius = (int)args[1];

                return ProcessFindTranslocator(api, context, addWaypoints, radius);
            });

        api.ChatCommands.Create("countwaypoints")
            .WithDescription("Counts the waypoints generated by this mod within this world, as well as any others. Waypoints are stored on the client system to prevent duplication.")
            .HandleWith(_ => context.GetCollectionPerSaveCount("waypoints", context.SaveData.WayPointsPerSavegame)

         );
        foreach (var command in config.Commands) CreateCommand(api, context, config, command);
    }

    public static void CreateCommand(ICoreClientAPI api, Context context, Nf3tConfig config, LocatorCommand command)
    {
        System.Func<BlockSelector, bool> predicate = s => s.Keywords.Contains(command.Keyword);

        api.ChatCommands.Create(command.Name)
            .WithDescription(command.Description)
            // Added a boolean parser. Optional(false) makes it default to false if omitted.
            .WithArgs(
                api.ChatCommands.Parsers.OptionalBool("addWaypoints"),
                api.ChatCommands.Parsers.OptionalInt("radius", config.DefaultSearchRadius))
            .HandleWith(args =>
            {
                var addWaypoints = true.Equals(args[0]);
                var radius = (int)args[1];

                var filteredSelectors = config.Selectors
                    .Where(predicate)
                    .ToList();

                Func<BlockPos, BlockPos, List<WayPoint>, Block, BlockPos, bool> onBlock =
                    (_, _, results, block, pos) =>
                    {
                        foreach (var selector in filteredSelectors)
                            if (block.Code.Path.StartsWith(selector.StartsWith))
                            {
                                var blockName = block.GetPlacedBlockName(api.World, pos);
                                var wayPoint = new WayPoint(block.Code.Path, pos.Copy(), blockName, selector.Icon,
                                    selector.Color);
                                results.Add(wayPoint);
                                return true;
                            }

                        return true;
                    };

                return TranslocatorLocatorCmdModSystem.ProcessFindBlock(api, context, addWaypoints, radius,
                    command.ClosestOnly, onBlock);
            });
    }
    
    private static TextCommandResult ProcessFindTranslocator(ICoreClientAPI api, Context context, bool addWaypoints,
        int radius)
    {
        Func<BlockPos, BlockPos, List<WayPoint>, Block, BlockPos, bool> onBlock =
            (mapMiddlePos, playerPos, results, block, pos) =>
            {
                if (!block.Code.Path.StartsWith("statictranslocator")) return true;

                var isRepaired = false;

                if (block.Code.Path.StartsWith("statictranslocator-broken"))
                    isRepaired = false;
                else if (block.Code.Path.StartsWith("statictranslocator-normal")) isRepaired = true;

                BlockPos? destination = null;

                if (block is BlockStaticTranslocator translocatorBlock)
                {
                    isRepaired = translocatorBlock.Repaired;
                    api.Logger.Debug("[Translocator Locator] Found repaired status: {0} for {1}",
                        translocatorBlock.Repaired, pos);
                    var be = api.World.BlockAccessor.GetBlockEntity(pos);
                    if (be is BlockEntityStaticTranslocator translocator)
                    {
                        destination = translocator.TargetLocation;
                        api.Logger.Debug("[Translocator Locator] Found destination: {0} for {1}", destination, pos);
                    }
                }

                api.Logger.Debug("[Translocator Locator] Found translocator block: {0} at {1}", block.Code.Path, pos);

                var sourceWayPoint = new WayPoint(block.Code.Path, pos.Copy(), block.GetPlacedBlockName(api.World, pos),
                    "spiral", isRepaired ? "green" : "red");
                results.Add(sourceWayPoint);

                if (destination != null)
                {
                    // TODO: Technically this codepath is incorrect as it is the source's path
                    var destinationWayPoint = new WayPoint(block.Code.Path, destination.Copy(),
                        block.GetPlacedBlockName(api.World, destination),
                        "spiral", "green");
                    results.Add(destinationWayPoint);
                    // TODO: Maybe just add destination to each waypoint...
                    destinationWayPoint.ExtraChat =
                        " to " + sourceWayPoint.ToRelativeCoordinates(mapMiddlePos, playerPos);
                    sourceWayPoint.ExtraChat =
                        " to " + destinationWayPoint.ToRelativeCoordinates(mapMiddlePos, playerPos);
                    context.AddTranslocator(new SimplePos(pos.X, pos.Y, pos.Z), new SimplePos(destination.X, destination.Y, destination.Z));

                }
                else
                {
                    context.AddTranslocator(new SimplePos(pos.X, pos.Y, pos.Z), null);
                }

                return true;
            };

        return ProcessFindBlock(api, context, addWaypoints, radius, false, onBlock);
    }

    public static TextCommandResult ProcessFindBlock(ICoreClientAPI api, Context context, bool addWaypoints,
        int radius, bool closestOnly, Func<BlockPos, BlockPos, List<WayPoint>, Block, BlockPos, bool> onBlock)
    {
        if (api.World?.Player?.Entity == null) return TextCommandResult.Error("Player not found.");

        var playerPos = api.World.Player.Entity.Pos.AsBlockPos;
        var mapMiddlePos = api.World.DefaultSpawnPosition.AsBlockPos;
        var results = new List<WayPoint>();

        // TODO: possibly make the Y always 0 - MAX HEIGHT?
        api.World.BlockAccessor.SearchBlocks(playerPos.AddCopy(-radius, -radius, -radius),
            playerPos.AddCopy(radius, radius, radius), (block, pos) =>
                onBlock(mapMiddlePos, playerPos, results, block, pos));

        IEnumerable<WayPoint> query = results
            .OrderBy(tl => tl.DistanceTo(playerPos));

        if (closestOnly)
            query = query.GroupBy(wp => wp.Name)
                .Select(group => group.First());

        var sortedResults = query.Reverse().ToList();

        context.SaveData.WayPointsPerSavegame.TryGetValue(api.World.SavegameIdentifier, out var checkWayPoints);
        if (checkWayPoints == null)
        {
            checkWayPoints = new HashSet<WayPoint>();
            context.SaveData.WayPointsPerSavegame[api.World.SavegameIdentifier] = checkWayPoints;
        }

        var messages = new List<string>();
        foreach (var result in sortedResults)
        {
            messages.Add(result.ToChatString(mapMiddlePos, playerPos));
            if (addWaypoints)
            {
                if (checkWayPoints.Contains(result))
                    api.Logger.Debug($"WayPoint already exists: {result.Pos}");
                else
                    api.SendChatMessage(result.ToWaypointString());
            }
        }
        
        if (messages.Count > 0)
        {
            context.Save();

            var fullMessage = string.Join("\n", messages);
            api.ShowChatMessage(fullMessage);

            if (addWaypoints){
                checkWayPoints.UnionWith(sortedResults);
                try
                {
                    context.IsDirty = true;
                    context.Save();
                    return TextCommandResult.Success($"Found {sortedResults.Count} waypoints within {radius} blocks.");
                }
                catch (Exception e)
                {
                    return TextCommandResult.Error("Failed to save: " + e.Message);
                }
            }
            return TextCommandResult.Success($"Found {sortedResults.Count} waypoints within {radius} blocks.");
        }

        return TextCommandResult.Success($"Not found within {radius} blocks.");
    }
}